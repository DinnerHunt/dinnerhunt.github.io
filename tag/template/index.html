<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    template | dinnerhunt
</title>
<link rel="shortcut icon" href="https://dinnerhunt.cn/favicon.ico?v=1654671103475">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://dinnerhunt.cn/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://dinnerhunt.cn/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/stackoverflow-light.min.css">

<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://dinnerhunt.cn">
                <img class="avatar" src="https://dinnerhunt.cn/images/avatar.png?v=1654671103475" alt="">
            </a>
            <div class="site-title">
                <h1>
                    dinnerhunt
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/friend" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        template</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/Perfect_Matching_In_A_General_Graph/">
                        「Template」一般图的最大匹配
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-07-15</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-primary">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            随机算法
mt19937 sd;
struct Rand_Match
{
    int match[N],vis[N];
    vector&amp;lt;int&amp;gt; G[N];
    void add(int x,int y)
    {
        G[x].pb(y);
        G[y].pb(x);
    }
    int dfs(int x,mt19937 sd)
    {
        shuffle(G[x].begin(),G[x].end(),sd);
        vis[x] = 1;
        for(auto y: G[x])
            if(!match[y]) return vis[y] = 1,match[y] = x,match[x] =y,1;
        for(auto y: G[x])
        {
            int z = match[y];
            if(vis[z]) continue;
            match[x] = y,match[y] = x,match[z] = 0;
            if(dfs(z,sd)) return 1;
            match[y] = z,match[z] = y,match[x] = 0;
        }
        return 0;
    }
    void run(int n)
    {
        random_device seed;
        mt19937 sd(seed());
        int ans = 0;
        MM(match,0);
        FOR(k,1,10)
        {
            FOR(i,1,n)
                if(G[i].size() &amp;amp;&amp;amp; !match[i])
                {
                    fill(vis + 1, vis + 1 + n, 0);
                    ans += dfs(i,sd);
                }
            if(ans == n/2) break;
        }
//        PLN(ans);
        if(ans == n/2) PS(&amp;quot;Yes&amp;quot;);
        else PS(&amp;quot;No&amp;quot;);
        FOR(i,1,n) G[i].clear();
    }
}O_O;


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/Perfect_Matching_In_A_General_Graph/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/link-cut-tree/">
                        「Template」 Link-Cut-Tree
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-05</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-other_2">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            const int N = 3e5+10;
const double Pi = acos(-1.0);
ll a[N];
struct LCT
{
    #define ls(x) c[x][0]
    #define rs(x) c[x][1]
    ll top,c[N][2],fa[N],v[N],rev[N],q[N];
    inline void pushup(ll x){v[x] = v[ls(x)] +  v[rs(x)] + a[x];}
    inline void pushdown(ll x){if(rev[x]) rev[ls(x)]^=1,rev[rs(x)]^=1,rev[x]^=1,swap(ls(x),rs(x));}
    inline bool isroot(ll x){ return ls(fa[x])!=x &amp;amp;&amp;amp; rs(fa[x])!=x;}
    void rotate(ll x)
    {
        ll y=fa[x],z=fa[y],l,r;
        if(ls(y)==x)l=0;else l=1;r=l^1;
        if(!isroot(y)){ if(ls(z)==y) ls(z)=x;else rs(z)=x;}
        fa[x]=z,fa[y]=x, fa[c[x][r]]=y, c[y][l]=c[x][r],c[x][r]=y;
        pushup(y);pushup(x);
    }
    void splay(ll x)
    {
        top = 1;q[top] = x;
        for(ll i=x;!isroot(i);i=fa[i])q[++top]=fa[i];
        for(ll i=top;i;i--)pushdown(q[i]);
        while(!isroot(x))
        {
            ll y=fa[x],z=fa[y];
            if(!isroot(y))
            {
                if((ls(y)==x)^(ls(z)==y))rotate(x);
                else rotate(y);
            }
            rotate(x);
        }
    }
    //打通根到x的路径
    void access(ll x){for(ll t=0;x;t=x,x=fa[x])splay(x),rs(x)=t,pushup(x);}
    //换根
    void makeroot(ll x){access(x);splay(x);rev[x]^=1;}
    //找x节点在原树的根
    int find(ll x){access(x);splay(x);while(ls(x))x=ls(x);splay(x);return x;}
    // 将x和y拆出实链出来
    void split(ll x,ll y){makeroot(x);access(y);splay(y);}
    //断开x,y
    void cut(ll x,ll y){makeroot(x);if(find(y) == x &amp;amp;&amp;amp; fa[y] == x &amp;amp;&amp;amp; ls(y) == 0){fa[y] = rs(x) = 0;pushup(x);}}
    //链接x,y
    void link(ll x,ll y){makeroot(x);if(find(y)!=x) fa[x]=y;}
}O_O;


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/link-cut-tree/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/dijkstra_min_cost_flow/">
                        「Template」Dijkstra费用流
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-11-29</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-warning">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            广工-最大瘤版本
//MCMF-&amp;gt;init(N) -&amp;gt; MCMF.add(u,v,flow,cost) -&amp;gt; (flow,cost) = MCMF.run(s,t,UP)  
//其中UP参数表示求s到t的流量不超过UP的情况下的最小费用，无要求填INF即可  
//所有节点的id范围[0,N]  
const int MAXN = 10005;  
const int INF = 0x7fffffff;  
struct MinCostMaxFlow {  
    struct edge {  
        int v, f, c, r;  
        edge(int _v, int _f, int _c, int _r) :v(_v), f(_f), c(_c), r(_r) {}  
    };  
    int V = 0, H[MAXN + 5], dis[MAXN + 5], PreV[MAXN + 5], PreE[MAXN + 5];  
    vector&amp;lt;edge&amp;gt; G[MAXN + 5];  
    inline void init(int n) {  
        for (int i = 0; i &amp;lt;= V; ++i) G[i].clear();  
        V = n;  
    }  
    inline void add(int u, int v, int f, int c) {  
        G[u].push_back(edge(v, f, c, G[v].size()));  
        G[v].push_back(edge(u, 0, -c, G[u].size() - 1));  
    }  
    typedef pair&amp;lt;int, int&amp;gt; P;  
    P run(int s, int t, int f) {  
        int cost = 0, flow = 0, tf; fill(H, H + 1 + V, 0);  
        while (f) {  
            priority_queue &amp;lt;P, vector&amp;lt;P&amp;gt;, greater&amp;lt;P&amp;gt; &amp;gt; q;  
            fill(dis, dis + 1 + V, INF);  
            dis[s] = 0; q.push(P(0, s));  
            while (!q.empty()) {  
                P now = q.top(); q.pop();  
                int v = now.second;  
                if (dis[v] &amp;lt; now.first)continue;  
                for (int i = 0; i &amp;lt; G[v].size(); ++i) {  
                    edge&amp;amp; e = G[v][i];  
                    if (e.f &amp;gt; 0 &amp;amp;&amp;amp; dis[e.v] &amp;gt; dis[v] + e.c + H[v] - H[e.v]) {  
                        dis[e.v] = dis[v] + e.c + H[v] - H[e.v];  
                        PreV[e.v] = v, PreE[e.v] = i;  
                        q.push(P(dis[e.v], e.v));  
                    }  
                }  
            }  
            if (dis[t] == INF)break;  
            for (int i = 0; i &amp;lt;= V; ++i) H[i] += dis[i];  
            tf = f;  
            for (int v = t; v != s; v = PreV[v])  
                tf = min(tf, G[PreV[v]][PreE[v]].f);  
            f -= tf, flow += tf, cost += tf*H[t];  
        	for (int v = t; v != s; v = PreV[v]) {  
                edge&amp;amp; e = G[PreV[v]][PreE[v]];  
                e.f -= tf;  
                G[v][e.r].f += tf;  
            }  
        }  
        return P(flow, cost);  
    }  
}MCMF; 


宏版
const ll maxd = 1e5+10;
const ll inf = 1e18;

struct edge{ll to,rev, flow,cost;};
ll n,m,k,num;
vector&amp;lt;edge&amp;gt; G[maxd];
ll h[maxd],dis[maxd],pn[maxd],pe[maxd];

void add(ll u,ll v,ll flow,ll cost)
{
    G[u].push_back((edge){ v,(ll)G[v].size(),flow,cost });
    G[v].push_back((edge){ u,(ll)G[u].size() - 1,0,-cost });
}

void min_cost_flow(ll s,ll t,ll &amp;amp;min_cost,ll &amp;amp;max_flow)
{
    fill(h+1,h+1+num,0);
    min_cost = max_flow = 0;
    ll tot = inf;
    while(tot&amp;gt;0)
    {
        MINQ_P q;
        fill(dis, dis + 1 +  num,inf);
        dis[s] = 0; q.push(P(0ll,s));
        while(!q.empty())
        {
            ll u = q.top().ND,dist = q.top().ST; q.pop();
            if (dis[u] &amp;lt; dist)continue;
            F( G[u].size())
            {
                edge &amp;amp;e = G[u][i];
                if (e.flow &amp;gt; 0 &amp;amp;&amp;amp; dis[e.to] &amp;gt; dis[u] + e.cost + h[u] - h[e.to])
                {
                    dis[e.to] = dis[u] +e.cost + h[u] - h[e.to];
                    pn[e.to] = u,pe[e.to] = i;
                    q.push(P(dis[e.to],e.to ));
                }
            }
        }
        if (dis[t] == inf)break;
        // 所有点都要
        FOR(i,0,num) h[i] += dis[i];
        ll flow = tot;
        for (int i = t; i != s; i = pn[i]) flow = min(flow, G[pn[i]][pe[i]].flow);
        for (int i = t; i != s; i = pn[i])
        {
            edge&amp;amp; e = G[pn[i]][pe[i]];
            e.flow -= flow;
            G[i][e.rev].flow += flow;
        }
        tot -= flow;
        max_flow += flow;
        min_cost += flow * h[t];
    }
}
void init(){ FOR(i,1,n+n+3) G[i].clear(); }
ll a[maxd];
int main()
{
    __IN;__OUT;
    ll s, t,T;RLL(T);
    while(T--)
    {
        RLL(n);RLL(m);init(); s = 0 ,t = n+1 , num = t;
        ll min_cost, max_flow;
        min_cost_flow(s, t, min_cost, max_flow);
        PLN(-min_cost);
    }
    return 0;
}



                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/dijkstra_min_cost_flow/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/Spanning-Tree-Count/">
                        「Template」Matrix - Tree 矩阵树定理
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-22</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-warning">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            A[][]A[][]A[][] 表示临接矩阵
B[][]B[][]B[][] 表示度数矩阵
K[][]=B−AK[][] = B - AK[][]=B−A 表示基尔霍夫矩阵(Kirchhoff)
生成树的计数方案数为基尔霍夫矩阵的任意(k-1)次行列式
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;cmath&amp;gt;
using namespace std;
const int maxd = 305;
long long a[maxd][maxd];
void Gauss(int n)
{
    long long ans=1ll;
    for(int i=1;i&amp;lt;=n;++i)
    {
        for(int k=i+1;k&amp;lt;=n;++k)
        while(a[k][i])
        {
            long long d=1ll * a[i][i]/a[k][i];
            for(int j=i;j&amp;lt;=n;++j) a[i][j]= a[i][j] - 1ll * d*a[k][j];
            swap(a[i],a[k]),ans=-ans;
        }
        ans = ans*a[i][i];
    }
    if(ans &amp;lt; 0) ans = -ans;
    printf(&amp;quot;%lld\n&amp;quot;,ans);
}
void add(int x,int y)
{
    a[x][y] = a[y][x] = -1ll;
    a[x][x] ++, a[y][y]++;
}

int t,n,m;

int main()
{
//    freopen(&amp;quot;a.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);
//    freopen(&amp;quot;k.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);

    scanf(&amp;quot;%d&amp;quot;,&amp;amp;t);
    while(t--)
    {
        scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m);
        memset(a,0,sizeof(a));
        for(int i=1;i&amp;lt;=m;i++)
        {
            int x,y;scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;x,&amp;amp;y);
            add(x,y);
        }
        Gauss(n-1);
    }
    return 0;
}



生成数概率
const double eps = 1e-8;
const int N = 66;
double a[N][N];
lf Gauss(ll n)
{
    lf ans = 1.0;
    FOR(i,1,n)
    {
        ll p = i;
        FOR(j,i+1,n) if( a[p][i] - a[j][i] &amp;lt; -eps ) p = j;
        if(p != i) FOR(j,i,n)swap(a[i][j],a[p][j]);
        if(!a[i][i]) return 0;
        FOR(j,i+1,n)
        {
            double t = a[j][i] / a[i][i];
            _FOR(k,n,i) a[j][k] -= a[i][k] * t;
        }
        ans *= a[i][i];
    }
    return fabs(ans);
}
void solve()
{
    ll n;RLL(n);
    double k = 1.0;
    FOR(i,1,n) FOR(j,1,n)
        {
            RLF(a[i][j]);
            if(i == j) continue;
            if(a[i][j] &amp;gt; 1 - eps) a[i][j] -= eps;
            if(i &amp;lt; j) k *= (1 - a[i][j]);
            a[i][j] /= (1 - a[i][j]);
        }
    FOR(i,1,n)FOR(j,1,n) if(i!=j) a[i][i] += a[i][j] , a[i][j] = -a[i][j];
    printf(&amp;quot;%.8lf&amp;quot;,Gauss(n-1)*k);
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/Spanning-Tree-Count/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/roundinto/">
                        「Template」圆的面积交与并
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-15</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-success">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            #include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cmath&amp;gt;
#define INF 5000
typedef long long ll;
using namespace std;
const double PI = acos(-1);

// 存储圆心和半径 
struct Round {
	double x,y;
	double r;
} r[INF];

// 圆心距离 
double dis(Round a, Round b) {
	return sqrt(pow((a.x-b.x),2) + pow((a.y-b.y),2));
}

// 两个圆面积并、交 
double solve(Round a, Round b)  {
	double ret = 0.0; 
	double d = dis(a,b);
	
	// 外离和外切 
	if(d &amp;gt;= a.r + b.r) return 0.0;
	
	// 内含和内切 
	if(d &amp;lt;= fabs(a.r-b.r)) {
//		double r = a.r&amp;lt;b.r?a.r:b.r;				// 面积交 
		double r = a.r&amp;gt;b.r?a.r:b.r;				// 面积并 
		ret = PI * pow(r,2);
		
		return ret; 
	}
	double ang1 = acos(pow((a.r),2) + pow(d,2) - pow((b.r),2) / 2.0 / a.r / d);
	double ang2 = acos(pow((b.r),2) + pow(d,2) - pow((a.r),2) / 2.0 / b.r / d);
	
	// 两扇形面积合 - 四边形面积 
	ret = ang1*pow((a.r),2) + ang2*pow((b.r),2) - d*a.r*sin(ang1);
	double rod1 = PI * pow((r[0].r),2);
	double rod2 = PI * pow((r[1].r),2);
//	return ret; 								// 面积交
	return rod1+rod2-ret;						// 面积并 
}

int main() 
{
	scanf(&amp;quot;%lf %lf %lf&amp;quot;,&amp;amp;r[0].x,&amp;amp;r[0].y,&amp;amp;r[0].r);
	scanf(&amp;quot;%lf %lf %lf&amp;quot;,&amp;amp;r[1].x,&amp;amp;r[1].y,&amp;amp;r[1].r);
	double ans = solve(r[0],r[1]);
	printf(&amp;quot;%.3lf&amp;quot;,ans);
	
	return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/roundinto/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/polygonInto/">
                        「Template」多边形面积交与并
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-10-15</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-other_2">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            #include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 300;
const double eps = 1e-8;
int dcmp(double x){         //精度误差比较
    if(x &amp;gt; eps) return 1;
    return x &amp;lt; -eps ? -1 : 0;
}
struct Point{double x, y;}; //点结构体
double cross(Point a,Point b,Point c){return (a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y);}//叉积
Point intersection(Point a,Point b,Point c,Point d){//传入四点即两直线，输出交点
    Point p = a;
    double t =((a.x-c.x)*(c.y-d.y)-(a.y-c.y)*(c.x-d.x))/((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x));
    p.x +=(b.x-a.x)*t;
    p.y +=(b.y-a.y)*t;
    return p;//输出交点，证明用数学方法易证
}
double PolygonArea(Point p[], int n){//计算多边形面积，三角剖分
    if(n &amp;lt; 3) return 0.0;
    double s = p[0].y * (p[n - 1].x - p[1].x);
    p[n] = p[0];
    for(int i = 1; i &amp;lt; n; ++ i)
        s += p[i].y * (p[i - 1].x - p[i + 1].x);
    return fabs(s * 0.5);//叉乘出来是平行四边形面积故/2，且顺逆方向不定，故取ABS变正
}
double CPIA(Point a[], Point b[], int na, int nb){//传入两个三角形，求相交部分的凸包
    Point p[20], tmp[20];           //复制点集与临时点集（P其实可以用B来做
    int tn, sflag, eflag;           //每轮相交凸包的点，叉乘符号
    a[na] = a[0], b[nb] = b[0];     //末点用初点复制方便首末点连边
    memcpy(p,b,sizeof(Point)*(nb + 1));         //把B复制到P
    for(int i=0;i&amp;lt;na&amp;amp;&amp;amp;nb&amp;gt;2;i++){                //扫一次A
        sflag=dcmp(cross(a[i+1],p[0],a[i]));    //取A两点与B第一点求叉乘符号
        for(int j=tn=0;j&amp;lt;nb;j++,sflag=eflag){   //扫一次B，更新TMP，TN是点数
            if(sflag&amp;gt;=0)tmp[tn++]=p[j];         //叉乘为正就是B数组的那个点压入
            eflag=dcmp(cross(a[i+1],p[j+1],a[i]));//求叉乘符号
            if((sflag^eflag)==-2)               //1异或-1等于-2
            tmp[tn++]=intersection(a[i],a[i+1],p[j],p[j+1]);//求交点
        }
        memcpy(p, tmp, sizeof(Point) * tn);     //把TMP复制到P
        nb = tn, p[nb] = p[0];//TN即TMP点数记到NB
    }//其实该是NP表示P数组个数，这里省了个变量就用NB表示，下面第二行做参数而已
    if(nb &amp;lt; 3) return 0.0;      //相交部分凸包不够三个点，面积就是0
    return PolygonArea(p, nb);  //求出相交凸包部分的面积
}
double SPIA(Point a[], Point b[], int na, int nb){//传入两个多边形的点
    int i,j;                            //循环变量
    Point t1[4],t2[4];                  //其实T13与T23没用上
    double res=0,num1,num2;             //答案初始化，及叉乘符号
    a[na]=t1[0]=a[0],b[nb]=t2[0]=b[0];  //初始化T1,T2和ANA,BNB
    for(i=2;i&amp;lt;na;i++){                  //扫一次第一个多边形全部点
        t1[1]=a[i-1],t1[2]=a[i];        //每次在第一个多边形取两个点赋给T11,T12
        num1=dcmp(cross(t1[1],t1[2],t1[0]));//求出叉乘符号
        if(num1&amp;lt;0)swap(t1[1],t1[2]);    //小于0则改变T11,T12可使叉乘符号变正，实即改变T1三个点的顺逆
        for(j=2;j&amp;lt;nb;j++){              //扫一次第二个多边形全部点
            t2[1]=b[j-1],t2[2]=b[j];    //然后再在第二个多边形取两个点赋给T21,T22
            num2=dcmp(cross(t2[1],t2[2],t2[0]));//求出叉乘符号
            if(num2&amp;lt;0)swap(t2[1],t2[2]);//小于0则改变T11,T12可使叉乘符号变正，实即改变T1三个点的顺逆
            res+=CPIA(t1,t2,3,3);       //累加相交部分面积
        }
    }
    return res; // 面积交
    return PolygonArea(a,na)+PolygonArea(b,na)-res
}
Point p1[maxn], p2[maxn];//两个数组存读入点集
int main(){
    int n1, n2;         //定义
    while(cin&amp;gt;&amp;gt;n1&amp;gt;&amp;gt;n2){ //输入两个多边形的点数
        for(int i=0;i&amp;lt;n1;i++)scanf(&amp;quot;%lf%lf&amp;quot;,&amp;amp;p1[i].x,&amp;amp;p1[i].y);//输入点数
        for(int i=0;i&amp;lt;n2;i++)scanf(&amp;quot;%lf%lf&amp;quot;,&amp;amp;p2[i].x,&amp;amp;p2[i].y);//输入点数
        cout&amp;lt;&amp;lt;SPIA(p1,p2,n1,n2)&amp;lt;&amp;lt;endl;//输出面积交
    }
    return 0;
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/polygonInto/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/MHD-MST/">
                        「Template」 曼哈顿最小生成树
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-09-29</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-warning">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Mannattan_minimum_spanning_tree 为添边操作
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long ll;
const ll mod = 1e9+7;
const int maxd = 2e5+10;
const int inf = 0x3f3f3f3f;
struct Point{
    int x,y,id;
    bool operator &amp;lt; (const Point &amp;amp;b) const
    { return b.x == x? y &amp;lt; b.y: x&amp;lt;b.x; }
}p[maxd],tmp[maxd];
struct Edge
{ 
    int u,v,d; 
    bool operator &amp;lt; (const Edge &amp;amp;b) const
    { return d &amp;lt; b.d;}
} e[maxd&amp;lt;&amp;lt;2];
int tot;
int fa[maxd],t[maxd],pos[maxd];
int gf(int x){
    if(fa[x] == x) return x;
    else return fa[x] = gf(fa[x]);
}
void update(int x,int v,int pp)
{
    for(;x; x -=(x&amp;amp;-x))
        if(v &amp;lt; t[x]) t[x] = v,pos[x] = pp;
}
int query(int x,int m)
{
    int ans = inf,pp = -1;
    for(;x&amp;lt;=m; x+=(x&amp;amp;-x))
        if(t[x] &amp;lt; ans)  ans = t[x], pp = pos[x];
    return pp;
}
int dis(Point a,Point b)
{
    return abs(a.x - b.x) + abs(a.y - b.y);
}
void Mannattan_minimum_spanning_tree(int n, Point p[])
{
    int a[maxd],b[maxd];
    for(int dir = 0; dir &amp;lt; 4;dir++)
    {
        if(dir == 1 || dir == 3) for(int i = 0;i &amp;lt; n;i++) swap(p[i].x,p[i].y);
        else if(dir == 2) for(int i = 0;i &amp;lt; n;i++) p[i].x = -p[i].x;
        sort(p,p+n);
        for(int i = 0;i &amp;lt; n;i++) a[i] = b[i] = p[i].y - p[i].x;
        sort(b,b+n);
        int m = unique(b,b+n) - b;
        for(int i = 1;i &amp;lt;= m;i++) t[i] = inf,pos[i] = -1;
        for(int i = n-1 ;i &amp;gt;= 0;i--)
        {
            int pos = lower_bound(b,b+m,a[i]) - b + 1;
            int ans = query(pos,m);
            if(ans != -1) e[++tot] = (Edge) {p[i].id,p[ans].id,dis(p[i],p[ans])};
            //addedge(p[i].id,p[ans].id,dis(p[i],p[ans]));

            update(pos,p[i].x+p[i].y,i);
        }
    }
}
int n,m;
int main()
{
    // freopen(&amp;quot;a.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);
    // freopen(&amp;quot;k.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);
    while(scanf(&amp;quot;%d %d&amp;quot;,&amp;amp;n,&amp;amp;m)!=EOF)
    {
        for(int i = 1;i&amp;lt;=n;i++)
            for(int j = 1;j&amp;lt;=m;j++)
            {
                p[(i-1)*m+j].id = (i-1)*m+j;
                scanf(&amp;quot;%d&amp;quot;,&amp;amp;p[(i-1)*m+j].x);
            }
        for(int i = 1;i&amp;lt;=n;i++)
            for(int j = 1;j&amp;lt;=m;j++)
                scanf(&amp;quot;%d&amp;quot;,&amp;amp;p[(i-1)*m+j].y);
        tot = 0;
        for(int i = 1;i&amp;lt;=n;i++)
        {
            int C = 0;
            for(int j = 1;j&amp;lt;=m;j++)
                tmp[C++] = p[(i-1)*m+j];
            Mannattan_minimum_spanning_tree(C,tmp);
        }
        for(int j = 1;j&amp;lt;=m;j++)
        {
            int C = 0;
            for(int i = 1;i&amp;lt;=n;i++)
                tmp[C++] = p[(i-1)*m+j];
            Mannattan_minimum_spanning_tree(C,tmp);
        }

        for(int i=1;i&amp;lt;=n*m;i++) fa[i] = i;
        sort(e+1,e+tot+1);
        ll ans = 0ll;
        for(int i = 1;i &amp;lt;= tot;i++)
        {
            int x = gf(e[i].u) , y = gf(e[i].v);
            if(x!=y)
            {
                fa[x] = y;
                ans += e[i].d;
            }
        }
        printf(&amp;quot;%lld\n&amp;quot;,ans);
    }
}


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/MHD-MST/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/Some-Partition/">
                        「Template」点分治
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-05-05</time>
                    
                        <a href="https://dinnerhunt.cn/tag/ZV90KMNKN/" class="post-tag i-tag
                            i-tag-banana">
            #点分治
        </a>
                        
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-error">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            P4178 Tree
问树上点权小于等于k的路径个数
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int maxd = 1e5;
struct node
{
	int v,net,dis;
}e[maxd*2];
int f[maxd],eid,k;
long long ans;
int sz[maxd],son[maxd],d[maxd],vis[maxd],tot;
int n,m,root,cnt,flag;
void init()
{
	memset(f,-1,sizeof(f));
	eid = 0;
}
void insert(int a,int b,int dis)
{
	e[eid].v = b;
	e[eid].net = f[a];
	e[eid].dis = dis;
	f[a] = eid++;
}

void Get_Root(int x,int fa) //找根
{
	son[x] = 0,sz[x] = 1;
	for(int i=f[x];i+1;i=e[i].net)
	{
		int v = e[i].v;
		if(v==fa||vis[v]) continue;
		Get_Root(v,x);
		son[x] = max(son[x],sz[v]);
		sz[x] += sz[v];		
	}
	son[x] = max(son[x],tot - sz[x]);
	if(son[x] &amp;lt; son[root]) root = x;
}
void Get_dis(int x,int fa,int len) // 统计当前重心到各个点的距离
{
	for(int i=f[x];i+1;i=e[i].net)
	{
		int v = e[i].v;
		if(vis[v]||v == fa) continue;
		d[++cnt] = len + e[i].dis;
		Get_dis(v,x,d[cnt]);
	}
}
int find(int l,int r,int v)
{
	int res = 0;
	while(l&amp;lt;=r)
	{
		int mid = (l+r)&amp;gt;&amp;gt;1;
		if(d[mid]&amp;lt;=v) res = mid, l = mid+1;
		else r = mid-1;
	}
	return res;
}
void Get_Ans(int x,int dis,int w)	//统计当前点的符合条件数
{
	d[cnt=1] = dis;	//	加入0，覆盖一条边的统计
	Get_dis(x,0,dis);
	sort(d+1,d+1+cnt);
	while(cnt &amp;amp;&amp;amp; d[cnt] &amp;gt; k) cnt--;
	while(cnt) ans += w*find(1,cnt-1,k-d[cnt]),cnt--;
}
void Point_Divid(int x)
{
	vis[x] = 1;
	Get_Ans(x,0,1); 
	for(int i=f[x];i+1;i=e[i].net)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		Get_Ans(v,e[i].dis,-1);
		tot = sz[v];root = 0;
		Get_Root(v,x),Point_Divid(root);
	}
}

int main()
{
	// freopen(&amp;quot;a.in&amp;quot;,&amp;quot;r&amp;quot;,stdin);
	// freopen(&amp;quot;k.out&amp;quot;,&amp;quot;w&amp;quot;,stdout);
	init(); scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;n;i++)
	{
		int x,y,z;
		scanf(&amp;quot;%d %d %d&amp;quot;,&amp;amp;x,&amp;amp;y,&amp;amp;z);
		insert(x,y,z);
		insert(y,x,z);
	}
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;k);
	tot = n; son[0] = 1e9;Get_Root(1,0);
	Point_Divid(root);
	printf(&amp;quot;%lld&amp;quot;,ans);
	return 0;
}	


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/Some-Partition/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/hash/">
                        「Template」 Hash
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-05-04</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            构造字符串的HASH表，O(1) 时间内对其子串进行判断是否相等

struct
{
    ll M = 11411;
    ull pre[N],id[N];
    char s[N];
    void init()
    {
        pre[0] = 1; M = 11411;//233
        FOR(i,1,N-1)pre[i] = pre[i-1]* M;
        FOR(i,1,n) id[i] = id[i-1] * M + (s[i] - &#39;a&#39; +1);
    }
    ull gethash(ll l,ll r)
    {
        return id[r] - id[l-1] * pre[r-l+1];
    }
}O_O;


                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/hash/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/template/">
                        Algorithm-Template
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2019-05-04</time>
                    
                        <a href="https://dinnerhunt.cn/tag/template/" class="post-tag i-tag
                            i-tag-error">
            #template
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                    <div class="post-content-abstract">
                                        <p>收录一些常数巨大的模版</p>

                                    </div>
                                    
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/template/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://dinnerhunt.cn/images/avatar.png?v=1654671103475)">
        </div>
        <h1 class="id_card-title">
            dinnerhunt
        </h1>
        <h2 class="id_card-description">
            
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.css" integrity="sha384-b/NoaeRXkMxyKcrDw2KtVtYKkVg3dA0rTRgLoV7W2df3MzeR1eHLTi+l4//4fMwk" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.js" integrity="sha384-ern5NCRqs6nJ/a4Ik0nB9hnKVH5HwV2XRUYdQl09OB/vvd1Lmmqbg1Mh+mYUclXx" crossorigin="anonymous"></script> | 
  <a class="rss" href="https://dinnerhunt.cn/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>