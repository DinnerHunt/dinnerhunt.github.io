<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>
    题解 | dinnerhunt
</title>
<link rel="shortcut icon" href="https://dinnerhunt.cn/favicon.ico?v=1654671103475">
<!-- <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous"> -->
<link href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://dinnerhunt.cn/styles/main.css">
<!-- js -->
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<script src="https://dinnerhunt.cn/media/js/jquery.sticky-sidebar.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/stackoverflow-light.min.css">

<script src="https://cdn.bootcss.com/moment.js/2.23.0/moment.min.js"></script>


</head>

<body>
    <div class="main">
        <div class="header">
    <div class="nav">
        <div class="logo">
            <a href="https://dinnerhunt.cn">
                <img class="avatar" src="https://dinnerhunt.cn/images/avatar.png?v=1654671103475" alt="">
            </a>
            <div class="site-title">
                <h1>
                    dinnerhunt
                </h1>
            </div>
        </div>
        <span class="menu-btn fa fa-align-justify"></span>
        <div class="menu-container">
            <ul>
                
                    
                            <li>
                                <a href="/" class="menu">
                                    首页
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/archives" class="menu">
                                    归档
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/tags" class="menu">
                                    标签
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/about" class="menu">
                                    关于
                                </a>
                            </li>
                            
                                
                    
                            <li>
                                <a href="/post/friend" class="menu">
                                    友链
                                </a>
                            </li>
                            
                                
            </ul>
        </div>
    </div>
</div>

<script>
    $(document).ready(function() {
        $(".menu-btn").click(function() {
            $(".menu-container").slideToggle();
        });
        $(window).resize(function() {

            if (window.matchMedia('(min-width: 960px)').matches) {
                $(".menu-container").css('display', 'block')
            } else {
                $(".menu-container").css('display', 'none')
            }

        });
    });
</script>

            <div id="main-content" class="post-container main-container">
                <div id="content" class="main-container-left">
                    
    <div class="i-card">
        <b>标签：#
        题解</b>
    </div>
    
        
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/ NCRound15/">
                        「牛客OI 周赛15」
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-04-05</time>
                    
                        <a href="https://dinnerhunt.cn/tag/3K1HRZrVeP/" class="post-tag i-tag
                            i-tag-other_1">
            #题解
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            Code
PJ 咪咪游戏
PJ 三角形
PJ 区间加
PJ 多元组
TG 环球旅行
TG 恢复数列
TG 回到过去
PJ 咪咪游戏
签到题，同时满足两个条件即可

字符串长度为偶数
奇数位为&#39;m&#39;,偶数位位&#39;q&#39;

PJ 三角形
一种很直观的办法，将每个数当作多项式的指数，出现次数为该指数的系数
然后将这nnn个多项式乘起来，则可以通过系数得到每个值出现的次数
因为最大值不超过1e41e41e4，所以我们可以很容易的想到用FFT加速多项式乘法

Ps.\text{Ps.}Ps. 这里要注意一点，FFT中实数部分可能会炸精度，每次乘完之后要对次数上界kkk取个minminmin,不然只能得到505050分的暴力分

PJ 区间加
设a[i]a[i]a[i]为第iii个位置增长到mmm还需要加多少次，也就是需要被区间覆盖多少次
因为每个位置只能放一个左括号和右括号，所以如果对于任意的iii,如果abs(a[i]−a[i−1])&amp;gt;1abs(a[i] - a[i-1]) &amp;gt; 1abs(a[i]−a[i−1])&amp;gt;1，则一定无法满足情况，直接输出000即可，这个可以感性理解
这是对于每个a[i]a[i]a[i] ，它与周围的a[i]a[i]a[i]的差值不会超过111
如果a[i]=a[i−1]−1a[i] = a[i-1]-1a[i]=a[i−1]−1,说明相较于a[i−1]a[i-1]a[i−1]，当前位置的值少了111，因此当前位置需要摆一个右括号
PJ 多元组
因为M&amp;lt;50M &amp;lt; 50M&amp;lt;50，所以我们可以依次求出1−m1 - m1−m元组
离散化后用树状数组求出对于每个位置为结尾的二元组数量
然后再用二元组求三元组，依次到MMM元组即可
TG 环球旅行
求拆边后的最小树直径
很显然删边一定是删原树直径上的边，并且删边后的最长路径一定有一端是原直径的一端，于是预先处理出每个点对于非直径点上的最长延边，然后统计即可
先一遍DFS求出最远点，然后再以这个最远点为起点做一遍DFS的同时，维护一个子树到该节点的最远点和次远点，从根节点开始，依次往后的最远点就是直径上的点，然后再做一遍DFS统计即可
TG 恢复数列

林琦定理 - 只用pow(x, 0)和pow(x, 1)一定能凑出一个x的整次幂
暴力枚举 0和 1的个数判断即可

TG 回到过去
因为 ∑1nai&amp;lt;=1e5\sum_1^n{a_i} &amp;lt;= 1e5∑1n​ai​&amp;lt;=1e5，所以不同数的个数不会超过n\sqrt{n}n​
可以先预处理出背包值的前缀preprepre和后缀sufsufsuf，然后对于某个值a[i]a[i]a[i]，如果不需要该值，则对于pre[i−1]pre[i-1]pre[i−1]和suf[i+1]suf[i+1]suf[i+1]一定存在pre[i-1][j] &amp;amp;&amp;amp; suf[i+1][m-j]
然后在求背包的时候，可以用二进制拆分优化，因为dpdpdp的值只有0,10,10,1两种,所以可以bitsetbitsetbitset加速

                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/ NCRound15/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/2019ccpcjiangxi/">
                        「 2019CCPC」- 江西省赛
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-02-27</time>
                    
                        <a href="https://dinnerhunt.cn/tag/3K1HRZrVeP/" class="post-tag i-tag
                            i-tag-primary">
            #题解
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                        <div class="post-content-content">
                                            HDU - 6567 Cotree


题意
给两棵树，可以在两棵树中添加一条边，使其变成一棵树，求∑in∑i+1ndis(i,j)\sum _i ^n \sum _{i+1} ^n dis(i,j)∑in​∑i+1n​dis(i,j) , dis(i,j)dis(i,j)dis(i,j) 表示点iii 与点jjj的距离


题解
因为任意两点之间的路径是唯一的，考虑树上一点xxx，如果点xxx的祖先节点要到达xxx的儿子节点，则一定需要经过点xxx。因此设sz[x]sz[x]sz[x] 为点xxx所包含的字节点数量(包括自身)，则xxx被经过的次数为点sz[x]∗(n−sz[x])sz[x] * (n- sz[x])sz[x]∗(n−sz[x])， 则总数量为 ∑insz[i]∗(n−sz[i])\sum _i^n sz[i] * (n- sz[i])∑in​sz[i]∗(n−sz[i])


代码


// 代码比较傻，因错误考虑，以为连接树的重心结果最优，实际无论怎样连，结果都一样
const ll maxd = 3e5+10;
V G[maxd];
ll d[maxd],sz[maxd],n,nod,num,ans,ss;
void dfs(ll x,ll fa,ll sd)
{
    d[x] = 1;
    ll mx = 0;
    for(auto v: G[x])
    {
        if(v != fa)
        {
            dfs(v,x,sd);
            d[x] += d[v];
            mx = max(mx,d[v]);
        }
    }
    mx = max(mx,sd-d[x]);
    if(mx &amp;lt; num)
    {
        nod = x;
        num = mx;
    }
}
void dfs1(ll x,ll fa)
{
    sz[x] = 1;
    for(auto v:G[x])
    {
        if(v==fa) continue;
        dfs1(v,x);
        sz[x]+=sz[v];
    }
    ans += (n - sz[x]) * sz[x];
}
void dfs3(ll x,ll fa)
{
    ss++;
    for(auto v: G[x]) if(v != fa) dfs3(v,x);
}
int main()
{
//    __IN;__OUT;
    RLL(n);ll a,b;
    FOR(j,1,n-2)
    {
        RLL2(a,b);
        G[a].pb(b);G[b].pb(a);
    }
    nod = 0, num = 1e9+10;
    dfs3(1,0);
    dfs(1,0,ss);
    a = nod;
    FOR(i,1,n)
        if(d[i] == 0)
        {
            nod = 0, num = 1e9+10;
            dfs(i, 0,n-ss);
            b = nod;
            break;
        }
    G[a].pb(b); G[b].pb(a);
    dfs1(1,0);
    PLN(ans);
    return 0;
}


HDU - 6574 Rng


题意
随机从范围[1,n][1,n][1,n]选取一个右端点ArA_rAr​ ，再从范围[1,Ar][1,A_r][1,Ar​]中选取一个左端点AlA_lAl​ ， 接着从范围[1,n][1,n][1,n]选取一个右端点BrB_rBr​,最后从范围[1,Br][1,B_r][1,Br​]中选取一个左端点BlB_lBl​
求区间 [Al,Ar]与[Bl,Br][A_l,A_r] \text{与}  [B_l,B_r][Al​,Ar​]与[Bl​,Br​] 相交的概率为多少 ，结果关于 modmodmod取模，分数取逆元


题解
我们考虑求出不相交概率，然后用111减去不相交，就是相交概率
设 a[i]a[i]a[i] 为区间左端点选到iii的概率
则a[i]=∑j=in1ja[i] = \sum _{j=i}^n \frac{1}{j}a[i]=∑j=in​j1​ , (样例2，区间左端点取到111的概率为 12+14\frac{1}{2} + \frac{1}{4}21​+41​, 右端点取到111的概率为12\frac{1}{2}21​,此时左端点必为111，右端点取到222，则左端点能取到111 或222 ， 因此概率为 34\frac{3}{4}43​)
可以从后往前，线性时间内推出 a[i]a[i]a[i]
当区间AlA_lAl​为 iii 时，[Bl][B_l][Bl​] 小于 iii时，则两区间不相交，考虑枚举iii，此时的概率为a[i]×i−1na[i] \times \frac{i-1}{n}a[i]×ni−1​
同理，考虑BlB_lBl​ 大于 ArA_rAr​时的概率与上面相同，因此直接乘二即可


代码


const ll maxd = 2e6+10;
ll a[maxd];
int main()
{
//    __IN;__OUT;
    ll n;
    while(RLL(n)!=EOF)
    {
        a[n+1] = 0;
        _FOR(i,n,1) a[i] = a[i+1]  + fpow(i*n,mod-2) %mod;
        ll lsum = 0; // A在B后面的总概率
        FOR(i,1,n)  (lsum +=a[i] *  (i-1) * fpow(n,mod-2))%=mod;
        ll y = 1, x = ((y - lsum * 2 ) %mod+mod) %mod;
        PLN(x);
    }
    return 0;
}


HDU - 6568 Math
参考题解


题意
你需要从位置000 走到位置ddd，你身上带了一个机器人 ，你每回合可以移动一格，并且每回合会发生如下事情

如果身上带着机器人，它有ppp的概率掉落在原地
如果机器人不在身上，你会有qqq的概率发现它丢了，如果此时位置为ddd，则你一定会发现它丢了
如果你发现机器人丢了，你会一直往左走，直到找到机器人 ，否则你往右走



题解
设s(i)s(i)s(i)为从位iii走到位置i+1i+1i+1的期望
如果机器人没丢，则期望步数为 (1−p)×1(1-p) \times 1(1−p)×1
如果丢了，你走到位置xxx才发现，则期望步数为(1−q)x−i∗q∗2∗(x−i)(1-q)^{x-i} * q * 2 * (x-i)(1−q)x−i∗q∗2∗(x−i) , 特别的,xxx上限为d−1d-1d−1 ，当x==dx == dx==d时，期望为  (1−q)d−i∗q∗2∗(d−i)(1-q)^{d-i} * q * 2 * (d-i)(1−q)d−i∗q∗2∗(d−i)
丢了之后会走回原地，因此需要重新考虑一边s(i)s(i)s(i) ,整理后
s(i)=(1−p)×1+p×(s(i)+(1−q)d−i∗q∗2∗(d−i)+(∑x=id−1(1−q)x−i∗q∗2∗(x−i)))s(i) = (1-p) \times 1 + p \times (s(i) +(1-q)^{d-i} * q * 2 * (d-i) + ( \sum_{x = i}^{d-1} (1-q)^{x-i} * q * 2 * (x-i)) )s(i)=(1−p)×1+p×(s(i)+(1−q)d−i∗q∗2∗(d−i)+(∑x=id−1​(1−q)x−i∗q∗2∗(x−i)))


代码


const ll mod = 1e9+7;
const ll maxd = 1e5+10;
double a[maxd],b[maxd];
int main()
{
//    __IN;__OUT;
    ll n; double p,q;
    while(RLL(n)!=EOF)
    {
        RLF(p);RLF(q);
        a[0] = 1; b[0] = 0;
        FOR(i,1,n)
        {
            a[i] = a[i-1] * (1-q);
            b[i] = b[i-1] + a[i] * i;
        }
        double ans = 0;
        F(n) ans += 1 + (2 * p * (a[n-i] * (n-i) + q * b[n-i-1])) / (1 - p);
        printf(&amp;quot;%.10lf\n&amp;quot;,ans);
    }
    return 0;
}

HDU - 6569 Trap


题意
有nnn根长度为aia_iai​线段，求组成不同种等腰梯形的数量种类 ，且该梯形所有边的最大公约数为111


题解
先不考虑最大公约数为111，因为数据范围为4000,因此可以枚举梯形的底边与腰。
设上底为AAA，下底为BBB ,腰为CCC，且A&amp;lt;BA &amp;lt; BA&amp;lt;B
考虑枚举上边AAA 与CCC，则$ A &amp;lt;= B &amp;lt;= A + 2 * C$
可以通过前缀和求出
因为要求最大公约数为111, 我们设F(i)F(i)F(i) 为最大公约数为 iii 的倍数的方案数，然后通过莫比乌斯进行容斥，求出最大公约数为111的方案数
如果求F(i)F(i)F(i) ，我们可以把枚举iii,然后只把长度为iii的倍数的线段拿出来构造梯形，这样构造出梯形的最大公约数一定是iii的倍数


代码


const ll maxd = 10010;
vector&amp;lt;vector&amp;lt;ll&amp;gt; &amp;gt; vec,fac;
ll pri[maxd],mu[maxd],tot;
ll cnt[maxd],a[maxd];
bool vis[maxd];
void init()
{
    fac.resize(maxd); mu[1] = 1;
    FOR(i,2,maxd-1)
    {
        if(!vis[i]) pri[++tot] = i,mu[i] =-1;
        FOR(j,1,tot)
        {
            if(i*pri[j] &amp;gt;= maxd) break;
            vis[i*pri[j]] = 1;
            if(i%pri[j] == 0)
            {
                mu[i*pri[j]] = 0;
                break;
            }
            else mu[i*pri[j]] = -mu[i];
        }
    }
    FOR(i,1,maxd)
        for(ll j=1;j*i&amp;lt;maxd;j++) fac[i*j].pb(i);
}
int main()
{
//    __IN;__OUT;
    ll n;
    init();
    while(RLL(n)!=EOF)
    {
        vec.resize(maxd);
        MM(cnt,0);
        FOR(i,1,n) RLL(a[i]);
        FOR(i,1,n) cnt[a[i]]++;
        FOR(i,1,n)
        {
            for(auto x: fac[a[i]])
            {
                vec[x].pb(a[i]);
            }
        }
        ll ans = 0;
        FOR(i,1,maxd-1)
        {
//            PLN(mu[i]);
            if(!vec[i].size() || mu[i] == 0) continue;
            ll sum = 0;
            sort(all(vec[i]));

            vec[i].erase(unique(all(vec[i])),vec[i].end());
//            PLN(i);
//            for(auto x:vec[i]) PLP(x);
//            PN();

            ll num  = vec[i].size();
            for(auto j:vec[i]) // 上底
            {
                ll l =0 , r=0;
                while(l &amp;lt; num &amp;amp;&amp;amp; vec[i][l] &amp;lt; j + 1) l++; // 下底
                for(auto k: vec[i]) // 枚举腰
                {
                    if( k != j &amp;amp;&amp;amp; cnt[k] &amp;gt;= 2)
                    {
                        while( r &amp;lt; num-1 &amp;amp;&amp;amp; vec[i][r+1] &amp;lt; j+ k*2) r++;
                        if(l&amp;lt; num &amp;amp;&amp;amp; r &amp;lt; num &amp;amp;&amp;amp; l &amp;lt;= r)
                        {
                            sum += r-l+1;
                            if(vec[i][l] &amp;lt;= k &amp;amp;&amp;amp; k &amp;lt;=vec[i][r] &amp;amp;&amp;amp; cnt[k] &amp;lt; 3) sum--;
                        }
                    }
                    else if(j == k &amp;amp;&amp;amp; cnt[j] &amp;gt;= 3) // 如果上底与高相同
                    {
                        while(r &amp;lt; num-1 &amp;amp;&amp;amp; vec[i][r+1] &amp;lt; j + k * 2) r++;
                        if(l &amp;lt; num &amp;amp;&amp;amp; r&amp;lt; num &amp;amp;&amp;amp; l&amp;lt;=r) sum += r - l + 1;
                    }
                }
            }
            ans += sum * mu[i];
//            PLN(sum);
//            PN();
        }
        PLN(ans);
    }
    return 0;
}

HDU - 6571  Packing


题意
有mmm个传送带与nnn个物品，第iii个物品第tit_iti​秒会被送到第mmm床送带，你可以在一秒中之内将一个物品从一个床送带上拿下来，每个传送带可容纳的商品数量为aia_iai​，当一秒结束时，如果第iii条传送带上的剩余物品数量numinum_inumi​大于aia_iai​，则会收取ai−numia_i -num_iai​−numi​的价钱 ，如果安排你的时间，使得价钱最少


题解
v2[i]v2[i]v2[i] 到iii时刻时共有多少个物品到达
v1[i]v1[i]v1[i] 到iii时刻时共有多少个物品超过限制


代码


const ll maxd = 1e6+10;
ll a[maxd];
V b[maxd];
ll v1[maxd],v2[maxd];
int main()
{
//    __IN;__OUT;
    ll n,m;RLL2(n,m);
    FOR(i,1,n)
    {
        ll t,x;
        RLL2(t,x);b[x].pb(t);
    }
    FOR(i,1,m) RLL(a[i]);
    FOR(i,1,m) sort(all(b[i]));
    FOR(i,1,m)
        FOR(j,0,b[i].size()-1)
        {
            v2[b[i][j]]++;
            if(j &amp;gt;= a[i]) v1[b[i][j]]++;
        }

    ll p = 0, ans = 0;  // p表示当前选取的数量
    FOR(i,1,maxd-1)
    {
        v1[i] += v1[i-1];
        v2[i] += v2[i-1];
    }


    FOR(i,1,maxd-1)
    {
        if(v2[i] &amp;gt; p) p++; // 如果物品够选，着选
        if(p &amp;lt; v1[i]) ans += v1[i] - p;  // 如果物品选的数量没有超过当前超过容量的数量，则算上花费
    }
    PLN(ans);
    return 0;



                                        </div>
                                        
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/2019ccpcjiangxi/">Read More ~</a>
                            </div>
                </div>
            </article>
            
            <article class="post i-card">
                <h2 class="post-title">
                    <a href="https://dinnerhunt.cn/post/ucf-local-programming-contest-2015/">
                        UCF Local Programming Contest 2015
                    </a>
                </h2>
                <div class="post-info">
                    <time class="post-time">2020-02-27</time>
                    
                        <a href="https://dinnerhunt.cn/tag/3K1HRZrVeP/" class="post-tag i-tag
                            i-tag-error">
            #题解
        </a>
                        
                </div>
                <div class="post-article">
                    
                            <div class="post-content">
                                
                                    <div class="post-content-abstract">
                                        <p><a href="https://dinnerhunt-blog.oss-cn-shanghai.aliyuncs.com/file/UCF%20Local%20Contest%202015%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A.pdf">UCF Local Contest 2015解题报告[东华大学 ACM 集训队]🔗</a></p>

                                    </div>
                                    
                                            <a class="btn btn-text" href="https://dinnerhunt.cn/post/ucf-local-programming-contest-2015/">Read More ~</a>
                            </div>
                </div>
            </article>
            
                <!-- 翻页 -->
                
                </div>
                <!--  -->
                <div class="main-container-middle"></div>
                <!--  -->
                <div id="sidebar" class="main-container-right">

                    <!-- 个人信息 -->
                    
    <div class="id_card i-card">
        <div class="id_card-avatar" style="background-image: url(https://dinnerhunt.cn/images/avatar.png?v=1654671103475)">
        </div>
        <h1 class="id_card-title">
            dinnerhunt
        </h1>
        <h2 class="id_card-description">
            
        </h2>
        <!--  -->
        <div class="id_card-sns">
            <!-- github -->
            
                    <!-- twitter -->
                    
                            <!-- weibo -->
                            
                                    <!-- facebook -->
                                    

        </div>
    </div>
    

                        <!-- 公告栏 -->
                        

                </div>
            </div>



            <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.css" integrity="sha384-b/NoaeRXkMxyKcrDw2KtVtYKkVg3dA0rTRgLoV7W2df3MzeR1eHLTi+l4//4fMwk" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.js" integrity="sha384-ern5NCRqs6nJ/a4Ik0nB9hnKVH5HwV2XRUYdQl09OB/vvd1Lmmqbg1Mh+mYUclXx" crossorigin="anonymous"></script> | 
  <a class="rss" href="https://dinnerhunt.cn/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
    <script>
        $('#sidebar').stickySidebar({
            topSpacing: 80,
            // bottomSpacing: 60
        });
    </script>
</body>

</html>